name: Terraform Apply

# Triggers: When does this workflow run?
on:
  push:
    branches:
      - main
    # Path Filters: Only run if files in these specific directories change.
    # This prevents deploying Prod when you only changed Dev, and vice versa.
    paths:
      - 'envs/dev/**'  # Trigger specific to Dev environment
      - 'envs/prod/**' # Trigger specific to Prod environment
      - 'modules/**'   # If modules change, we want to redeploy EVERYTHING to ensure compatibility.
  
  # Manual Trigger: Allows you to click "Run workflow" in GitHub UI.
  workflow_dispatch:

permissions:
  id-token: write # Required for requesting the JWT token for AWS OIDC authentication
  contents: read  # Required to checkout the code

jobs:
  # JOB 1: Detect Changes
  # This job runs first to calculate which environments need to be deployed.
  changes:
    runs-on: ubuntu-latest
    permissions:
      contents: read # Required to read the git history/diff
    outputs:
      # Expose the filter results so other jobs can use them "needs.changes.outputs.dev"
      dev: ${{ steps.filter.outputs.dev }}
      prod: ${{ steps.filter.outputs.prod }}
    steps:
      - uses: actions/checkout@v4
      
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          # Define filters: "name: path/glob"
          # If any file matches the glob, the filter output will be 'true'
          filters: |
            dev:
              - 'envs/dev/**'
              - 'modules/**'
            prod:
              - 'envs/prod/**'
              - 'modules/**'

  # JOB 2: Deploy to Development
  deploy-dev:
    name: Deploy API to Dev
    needs: changes # Wait for the 'changes' job to finish
    # Run if manual trigger OR if the 'dev' filter from the changes job was true
    if: github.event_name == 'workflow_dispatch' || needs.changes.outputs.dev == 'true'
    runs-on: ubuntu-latest
    environment: dev
    defaults:
      run:
        working-directory: envs/dev
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OCID)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::170974506299:role/aura-tf-cicd-ip-role
          aws-region: ap-south-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: terraform init

      - name: Terraform Format
        run: terraform fmt -check

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        # Generates an execution plan and saves it to a file named 'tfplan'.
        # Added -var-file so Terraform knows where to read values from.
        run: terraform plan -var-file="dev.tfvars" -out=tfplan

      - name: Terraform Apply
        # Applies the saved plan automatically without asking for confirmation (-auto-approve).
        run: terraform apply -auto-approve tfplan

  # JOB 3: Deploy to Production
  deploy-prod:
    name: Deploy API to Prod
    needs: changes
    # Run if manual trigger OR if the 'prod' filter from the changes job was true
    if: github.event_name == 'workflow_dispatch' || needs.changes.outputs.prod == 'true'
    runs-on: ubuntu-latest
    environment: prod
    defaults:
      run:
        working-directory: envs/prod
    
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OCID)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::170974506299:role/aura-tf-cicd-ip-role
          aws-region: ap-south-1

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        run: terraform init

      - name: Terraform Format
        run: terraform fmt -check

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        # Added -var-file so Terraform knows where to read values from.
        run: terraform plan -var-file="prod.tfvars" -out=tfplan

      - name: Terraform Apply
        run: terraform apply -auto-approve tfplan
